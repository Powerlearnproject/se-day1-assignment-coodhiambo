[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15568285&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

**Question 1:** Explain what software engineering is and discuss its importance in the technology industry.

**Answer:**
Software Engineering is the application of engineering principles , methods and tools in the design,development, testing, deployment and maintenance of software. 

Software Engineering is important in the technology industry because:

1. Through Software Engineering it is possible to deliver accurate and reliable software to automate human tasks, for example a software that controls the packaging of finished food items in a factory.

2. Software Engineering enables the ability to continously improve existing software systems through the rigor it offers in the analysis, testing and modelling of software products on sound theoretical models. 

3. Software Engineering enables the interfacing of different technological fields and hence providing a wider scope of application of software. 

For example embedded systems such as software controlling a microwave cooker, self drive cars and so on.


**Question 2:** Identify and describe at least three key milestones in the evolution of software engineering.

**Answer:**
1. The Communication Age (1993-2001).

   The key feature of this age was the development of the internet. This brought about a paradigm shift in the development of software. 
   
   Client/Server applications became prevalent with Web Engineering becoming a focal discipline that introduced standardization of key technologies used in the internet environment such as HTML, JavaScript, CSS. 
   
   It is during this era that emphasis on software quality monitoring became formalized through tools such as Capability Maturity Model (CMM) and Integrated Capability Maturity Model (CMMI).

2. The Productivity Age( 2002-2010).

   This age was characterized by the mass adoption of software technologies in the business environment in the form of Management Information Systems (MIS). 
   
   With customers playing an active role in what software should do and how, new development methodologies took center stage collectively called agile methodologies examples of which are Scrum and Extreme Programming. 

3. The Mass Market Era (2011 to Date).

   By this age, many players in the software industry existed with multiple solutions, many times addressing common problems. 
   
   A need for operational standards and operational efficiency became neccessary. This resulted in a conceptual development model emerging in the form of looking at functional software units as services. 
   
   Standards were developed to enable integration of many services in environments that enabled interoperability. 
   
   This birthed the service oriented architecture in software engineering and to date is pivotal in driving the now mature cloud computing paradigms namely, Software as a Service (SAAS), Infrastructure as a Service (IAAS), Platform as a Service (PAAS).


**Question 3:** List and briefly explain the phases of the Software Development Life Cycle.

**Answer:**
1. Planning.

   During planning the focus is on developig a comprehensive Project Plan that addresses time, cost, resources required as well as risks and challenges that the project may ran into. 
   
   Another key output of this stage is the Software Requirements Specification that addresses the user requirements or software functions and the feasibility of the software project from both technical as well as financial perspectives.

2. Requirements Analysis.

   During this stage, specific requirements are listed and described comprehensively. This is done through engagement with all the stakeholders to understand the essential as well as the desirable needs. 
   
   It's at this stage that the initial requirements list from the planning phase is refined and formally specified into an actual requirements specification document.

3. Design.

   In the design phase, an outline of the software functionality, its user interation model, look and feel, system architecture and data design is made. 
   
   through constant engagement with stakeholder as well as the development team, this evolves to become a system architecture and design specification that will guide the eventual coding process. 

4. Coding.

   The coding phase involves translation of the system architecture and design specification into an actual software product through the building of the software by using a specific programming language and its associated tools. 
   
   During this phase actual functionality building, security functions building, error identification and correction or debbuging as well as on going localized testing is carried out.

5. Testing.

   The formal testing phase involves the design of formal test parameters refered to as test cases. The goal of this phase is to test the software against the specified required and desired behaviour as well as boundary conditions that way present themselves during software execution. 
   
   The test cases also attempt to cover diverse conditions that may occur within the operating environment of the software. 
   
   The tests are carried out in formally specified stages such as unit testing, security testing, integration testing and acceptance testing.

6. Deployment.

   The deployment phase is an exciting phase that involves the unveiling of a functional product for the end users to trial out or actually use. 
   
   During this phase the software is rolled out in the actual user environment and key activities in this phase include environmental setup, installations, knowledge transfer to users, collection of user feedback, bug correction and continous user assistance or support. 

7. Maintenance.

   The maintenance phase is at the end of the software development life cycle and is key to making sure that the software continously meets the user needs either through constant and required upgrades or until inevitable upgrade or phase out becomes necessary. 
   
   During this phase continous support, knowledge transfer, bug fixes and delivery of upgrades or patches, documentation, adaptation of the software are typical activities that take place.

**Question 4:** Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.

**Answer:**

We can compare Waterfall and Agile Methodologies as below:

1. Both methodologies are goal oriented and hence focus on producing high quality end products.
2. Both methodologies encompass similar development life cycle phases the only factor being that each methodology executes and organises these phases differently througout the project life cycle.
3. Both Methodologies emphasize stakeholder involvement. Waterfall methodology does so through initial detailed analysis and specification while agile methodology does so through a continous involvement within the iterative incremental steps that the whole project is broken down into.   
4. Both use project management tools for tracking project progress for example use of Gantt charts and Kanban boards

We can contrast Waterfall and Agile Methodologies as below:

1. Waterfall methodology uses a sequential approach whereas Agile uses an iterative and incremental approach.
2. Waterfall is rigid and thus aligning itself to the initial specification while agile is highly 
flexible and adaptive to prevailing user needs and development environment.
3. Waterfall has an initial intensive customer engagement especially during the requirement analysis phase while agile has a high level of customer involvement throughout the project lifecycle.
4. Waterfall employs a formal risk assessment and management specification at the beginning of the project whereas agile employs continous risk management.

The Waterfall methodology works best for projects with Less complex objectives and requirements, projects with predictable outcomes, projects that are easily replicable and proven, for project teams that do not require constant collaboration or can work independently without frequent communication. 

The agile methodology is suited for ongoing projects and projects where certain details aren't known from the outset. This methodology is especially beneficial for projects that are complex.


**Question 5:** Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.

**Answer:**
1. Software Developer Role

   The core role of a software developer is to correctly interpret software architecture and design specification into code that can implement the specified functionality. by extension they should also implement correct and sufficient documentation and develop the soution in such a way that formal testing can be carried out. 

2. Quality Assurance Engineer Role.

   The QA Engineer ensures that the software works correctly and according to user specification, in addition to this they ensure that the product has been built according to expected and applicable standards that are observable or demonstrateable. The QA ensures that this is achieved by supervising the testing process where each of these key questions can be asked and consequently answered. 

3. Project Manager Role.

   The project manager is the overall team lead ensuring that a smooth channel of communication exists within the team players as well as between the team and the customer team, through relevant, focussed and actionable meetings. The project manager ensures that project timelines ad budgets are adhered to and that any changes are properly documented and the change effect addressed. The project manager focuses on continously aligning both sides of the project divide to the defined goals and eventual handover of an effective, funtional product. 


**Question 6:** Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.

**Answer:**
1. Integrated Development Environments.
 
 This is a software that integrates core functionalities that simplify the development of other software products. In general most standard IDE's would integrate a code editor for writing the code, a compiler or translator for converting the code into machine executable form, debugging tools that enable the trapping of errors and getting related information. other tools may also be bundled with IDEs such as build tools used to ensure that during the development of a software, the dependencies for a certain feature are availed to the development environment. examples of IDEs are Visual Studio Code, Eclipse , Netbeans, IntelliJ. The integration of this features into a single software makes the development process more efficient and productive.

2. Version Control Systems.

   Version Control Systems are software products that track the changes made to a file or sets of related files. From the point of view of software development this is important because it enables the collaboration of multiple team members working on the same project and allows separation of work and providing a means to merge a selected path into the final product. By tracking changes and providing a separate area of storage of stored files, version control systems provide a means of tracking changes to files, remote backup of files, enabling of reverting to earlier versions of development. We can therefore see that version control systems are highly beneficial by providing collaboration mechanisms, change tracking, version tracking and backup. Examples of version control tools are Git, Svn, BitBucket.

**Question 7:** What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.

**Answer:**

  Common challenges faced by Software Engineers are:

  1. Rapid Technological Advancement.
     Software Engineers can prepare themselves for rapid technological advancement through continous learning of emerging technologies and adaptation of their existing systems to comply with such changes.

  2. Security and Privacy Threats.
     The security challenges can be addressed by deliberate design of security features as part of any solution under development. Further, use of highly secure techniques such as strong encryption, strong password enforcement, 2 factor authentication can help address most security challenges.

  3. Scalability and Performance.
     Designing software that inherently is able to correctly allocate the required resources dynamically as well as architectures that support higher system throughput without degradation of performance can adress the scalability and performance issues. In general this issue is primarily solved through correct architectural specification.



**Question 8:** Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.

**Answer:**
1. Unit Testing is testing of the smallest testable piece of a software. It's important because it establishes early on the proper working of software at the building block level.

2. Integration Testing involves the testing of multiple parts of a software system together as a group. It is important because it acertains whether the units that make up the complete system work together to achieve the desired software functionality.

3. System testing is a type of testing that moves from code level tests to external functional tests. in otherwords in system testing user level inputs and the resulting outputs are verified to conform to the overall defined functionality of the software system. It's important because it confirms whether the stakeholder defined goals and desired system behaviour is demonstratable.   

4. Acceptance testing is the formal final stage of testing. It is the verification process that involves the project team demonstrating to stakeholders that the software has met the defined objectives. It is a process of checking off each testable item against a stakeholder defined list. This is in general a check off process and each task or group of tasks that have been accepted are signed off by the stakeholders. The importance of this test is that it confirms that the project has ended as per the initial brief and that the set goals have been met.


#Part 2: Introduction to AI and Prompt Engineering

**Question 1:** Define prompt engineering and discuss its importance in interacting with AI models.

**Answer:**
prompt engineering involves the design of queries called prompts that are specific, clear, concise and contexual. As far as AI Models are concerned, prompt engineering enables the AI tool to retrieve accurate and focused or relevant possibility of answers to a properly formed prompt.

**Question 2:** Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.

**Answer:**
Example of vague prompt:

Show me how to integrate a function.

Example of an improved prompt:

Show me how to integrate an exponential function.

The second prompt is more effective since it directs the AI tool to look up a more specific integration method hence preventing a return of all general formulas of integration.